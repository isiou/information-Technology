# 作用域

## 作用域定义

作用域规定了变量能够被访问的“范围”，离开了这个“范围”的变量便不能被访问。

### 局部作用域

#### 函数作用域

在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。

1. 函数内部声明的变量在函数外部无法被访问

2. 函数的参数也是函数内部的局部变量

3. 不同函数内部声明的变量无法互相访问

4. 函数执行完毕后，内部变量被清空

#### 块作用域

在 JavaScript 中使用 `{}` 包裹的代码被称为代码块，代码块内部声明的变量在外部**有可能**无法被访问。

1. let 声明的变量会产生块作用域而 var 不会

2. const 声明的常量会产生块作用域

3. 不同代码块之间的变量无法互相访问

4. var 声明的变量可能会导致变量名污染

### 全局作用域

`<script>` 标签和 `.js` 文件的最外层就是全局作用域。在此声明的变量在函数内部也可以被访问。

全局作用域中声明的变量，任何其他作用域都可以访问。

### 作用域链

作用域链的本质是底层的变量查找机制。

在函数被执行时，会优先查找当前函数作用域内的变量。如果当前作用域查找不到则会**依次逐级查找**父级作用域直到全局作用域。

1. 嵌套关系的作用域形成了作用域链

2. 相同作用域链中按照从小作用域到大作用域查找

3. 子作用域可以通过作用域链访问父作用域，父作用域无法访问子作用域

## 垃圾回收机制

JavaScript 中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。

### 内存的生命周期

JavaScript 环境中分配的内存，一般有以下生命周期：

1. 内存分配：当程序中声明函数、变量、对象时，系统会自动分配内存

2. 内存使用：即读写内存，即使用变量函数

3. 内存回收：使用完毕，由垃圾回收器自动回收不再需要使用的内存

全局变量一般不会自动回收，通常在关闭页面时回收。

局部变量的值再不用的时候一般会被自动回收。

内存泄漏：程序中分配的内存由于某种原因未释放或者无法释放称为内存泄漏。

## 闭包

一个函数对周围状态的引用捆绑在一起，内层函数访问到其外层函数的作用域。

即：内层函数使用外层函数的变量。

完整的闭包由内层函数和外部变量构成。

```js
function fn() {
  const a = 1;
  function f() {
    // 内层函数使用外层函数的变量
    console.log(a);
  }
  f();
}
fn();
```

闭包作用：封闭数据，提供操作，外部可以访问函数内部的变量。

### 常见的闭包形式

```js
function outer() {
  let a = 10;
  function fn() {
    console.log(a);
  }
  // 返回函数
  return fn;
}
// outer() == fn == function fn() {}
outer();
const fun = outer();
fun(); // 10
```

闭包导致变量不会被内存回收机制回收，有内存泄漏的风险。

## 提升

作用：在 JavaScript 中，执行代码之前会将函数声明放入内存中，同时程序也可在声明这个函数之前使用这个函数。

正常情况下，先声明函数再调用，如下：

```js
// 先声明函数
function getAdd(num1, num2) {
  console.log(num1 + num2);
}

// 使用函数
getAdd(1, 2);
```

某些情况下会先调用函数，再声明，如下：

```js
// 先调用函数
print("Chloe");

// 声明函数
function print(str) {
  console.log(str);
}
```

这种情况下，即使我们在定义这个函数之前调用它，函数仍然可以工作。这是因为在 JavaScript 中执行上下文的工作方式造成的。

变量提升也适用于其他数据类型和变量。变量可以在声明之前进行初始化和使用。但是如果没有初始化，就不能使用它们，如下：

> 此例子中，在函数调用过后 num 变量仍未声明，则 JavaScript 会抛出 num is not defined 错误。

```js
// 调用函数
fn(num);

function fn(num) {
  console.log(num);
}
```

> 在此例子中，函数调用后声明了 num 变量，则 JavaScript 会在函数中打印 num 为 undefined

```js
// 调用函数
fn(num);

function fn(num) {
  console.log(num);
}

var num = 10;
```

### 声明提升

JavaScript 只会提升声明，不会提升其初始化。如果一个变量先被使用再被声明和赋值的话，使用时的值是 undefined。参见例子：

```js
// 此项返回的为 undefined 即只提升了 num 的声明，但未初始化
console.log(num);
var num;
num = 6;
```

```js
// 先赋值
num = 6;
// 结果为6，即声明的 num 被提升到函数之前，可以得到值
console.log(num);
var num;
```

### 总结

引擎会在解释 JavaScript 代码之前首先对齐进行编译，编译过程中的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来，这也正是词法作用域的核心内容。

简单的来说，**变量提升就是在编译的过程中，将变量的声明和函数的声明提升至对应作用域的顶端，即会优先执行**。

同时，使用 let 和 const 声明的变量我们需要在赋值后才能进行访问，即不能在赋值前进行访问。因此其实尽量采取 let 或者 const 来声明相关的变量和函数。

var 与 let 的区别有：

1. 块作用域中：使用 var 声明的是全局变量，而 let 是局部变量

2. 重复声明：var 可以重复声明，而 let 不允许

3. 在全局中，使用 var 声明的变量会放到 window 对象导致污染全局，而 let 不会

4. 使用 let 声明的变量，会形成一个暂时性死区：即用 let const 或 class 声明的变量可以称其从代码块的开始一直到代码执行到变量声明的位置并被初始化前，都处于一个**暂时性死区**中，当变量处于暂时性死区之中时，其尚未被初始化，并且任何访问其的尝试都将导致抛出错误。当代码执行到变量被声明的位置时，变量会被初始化为一个值。如果变量声明中未指定初始值，则变量将被初始化为 undefined

JavaScript 提升的目的是：为了提前分配好内存空间,提高性能。
